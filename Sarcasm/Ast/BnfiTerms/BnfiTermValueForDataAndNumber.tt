<#@ template debug="true" hostSpecific="false" #>
<#@ output extension="generated.cs" #>
<#@ assembly Name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #> 
<#
	WriteLine("// GENERATED FILE");
#>

using System;
using System.Collections.Generic;
using System.Linq;

using Irony;
using Irony.Ast;
using Irony.Parsing;

namespace Sarcasm.Ast
{
<#
	foreach (TypeCode typeCode in Enum.GetValues(typeof(TypeCode)))
    {
		if (typeCode == TypeCode.Empty)
			continue;

		Type type = TypeCodeToType(typeCode);
		string methodNameExt = typeCode == TypeCode.Object ? string.Empty : typeCode.ToString();
		string typeParamsStr = typeCode == TypeCode.Object ? string.Empty : string.Format("<{0}>", typeCode);
#>
	#region Create <#= type.Name #> (<#= IsNumeric(typeCode) ? "Data and Number" : "Data" #>)

	#region BnfiTermValue

    public partial class BnfiTermValue
	{
        public static BnfiTermValue<#= typeParamsStr #> CreateData<#= methodNameExt #>(DataLiteralBase dataLiteral)
        {
<#
		if (typeCode != TypeCode.Object)
        {
#>
            if (dataLiteral.DataType != TypeCode.<#= typeCode #>)
                GrammarHelper.ThrowGrammarErrorException(GrammarErrorLevel.Error, "terminal '{0}' should be a <#= type.Name #>", dataLiteral.Name);

<#
        }
#>
            BnfiTermValue<#= typeParamsStr #> bnfiTermValue = Create<#= typeParamsStr #>(dataLiteral, (context, parseNode) => { return (<#= type.Name #>)parseNode.FindToken().Value; }, astForChild: false);
            bnfiTermValue.InverseValueConverterForUnparse = IdentityFunctionForceCast<<#= type.Name #>, object>;
            return bnfiTermValue;
        }
<#
		if (IsNumeric(typeCode))
        {
#>

		public static BnfiTermValue<#= typeParamsStr #> CreateNumber<#= methodNameExt #>(NumberLiteral numberLiteral)
        {
            BnfiTermValue<#= typeParamsStr #> bnfiTermValue = Create<#= typeParamsStr #>(numberLiteral, (context, parseNode) => { return (<#= type.Name #>)parseNode.FindToken().Value; }, astForChild: false);
            bnfiTermValue.InverseValueConverterForUnparse = IdentityFunctionForceCast<<#= type.Name #>, object>;
            return bnfiTermValue;
        }
<#
        }
#>
	}

	#endregion

	#region GrammarHelper

    public static partial class GrammarHelper
	{
        public static BnfiTermValue<#= typeParamsStr #> CreateData<#= methodNameExt #>(this DataLiteralBase dataLiteral)
        {
			return BnfiTermValue.CreateData<#= methodNameExt #>(dataLiteral);
        }
<#
		if (IsNumeric(typeCode))
        {
#>

		public static BnfiTermValue<#= typeParamsStr #> CreateNumber<#= methodNameExt #>(this NumberLiteral numberLiteral)
        {
			return BnfiTermValue.CreateNumber<#= methodNameExt #>(numberLiteral);
        }
<#
        }
#>
	}

	#endregion

	#region Grammar

    public partial class Grammar
	{
		#region Data

        public static BnfiTermValue<#= typeParamsStr #> CreateData<#= methodNameExt #>()
		{
			return new DataLiteralBase(name: "data<#= methodNameExt #>", dataType: TypeCode.<#= typeCode #>).CreateData<#= methodNameExt #>();
		}

        public static BnfiTermValue<#= typeParamsStr #> CreateData<#= methodNameExt #>Dsv()
		{
			return new DsvLiteral(name: "data<#= methodNameExt #>Dsv", dataType: TypeCode.<#= typeCode #>).CreateData<#= methodNameExt #>();
		}

        public static BnfiTermValue<#= typeParamsStr #> CreateData<#= methodNameExt #>Dsv(string terminator)
		{
			return new DsvLiteral(name: "data<#= methodNameExt #>Dsv", dataType: TypeCode.<#= typeCode #>, terminator: terminator).CreateData<#= methodNameExt #>();
		}

        public static BnfiTermValue<#= typeParamsStr #> CreateData<#= methodNameExt #>Quoted(string startEndSymbol)
		{
			return new QuotedValueLiteral(name: "data<#= methodNameExt #>Quoted", dataType: TypeCode.<#= typeCode #>, startEndSymbol: startEndSymbol).CreateData<#= methodNameExt #>();
		}

        public static BnfiTermValue<#= typeParamsStr #> CreateData<#= methodNameExt #>Quoted(string startSymbol, string endSymbol)
		{
			return new QuotedValueLiteral(name: "data<#= methodNameExt #>Quoted", dataType: TypeCode.<#= typeCode #>, startSymbol: startSymbol, endSymbol: endSymbol).CreateData<#= methodNameExt #>();
		}

        public static BnfiTermValue<#= typeParamsStr #> CreateData<#= methodNameExt #>FixedLength(int length)
		{
			return new FixedLengthLiteral(name: "data<#= methodNameExt #>FixedLength", dataType: TypeCode.<#= typeCode #>, length: length).CreateData<#= methodNameExt #>();
		}

		#endregion
<#
		if (IsNumeric(typeCode))
        {
#>

		#region Number

		public static BnfiTermValue<#= typeParamsStr #> CreateNumber<#= methodNameExt #>()
        {
			return new NumberLiteral(name: "number").CreateNumber<#= methodNameExt #>();
        }

		public static BnfiTermValue<#= typeParamsStr #> CreateNumber<#= methodNameExt #>(NumberOptions options)
        {
			return new NumberLiteral(name: "number", options: options).CreateNumber<#= methodNameExt #>();
        }

		#endregion
<#
        }
#>
	}

	#endregion

	#endregion

<#
    }
#>
}

<#+
Type TypeCodeToType(TypeCode typeCode)
{
	return Type.GetType("System." + typeCode.ToString());
}

bool IsNumeric(TypeCode typeCode)
{
	switch (typeCode)
    {
		case TypeCode.Byte:
		case TypeCode.Decimal:
		case TypeCode.Double:
		case TypeCode.Int16:
		case TypeCode.Int32:
		case TypeCode.Int64:
		case TypeCode.SByte:
		case TypeCode.Single:
		case TypeCode.UInt16:
		case TypeCode.UInt32:
		case TypeCode.UInt64:
		case TypeCode.Object:
			return true;

		default:
			return false;
    }
}
#>