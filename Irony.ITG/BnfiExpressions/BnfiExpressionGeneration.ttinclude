<#@ IntelliSenseLanguage processor="tangibleT4Editor" language="C#" #>
<#@ assemblyForIntellisenseOnly processor="tangibleT4Editor" Name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="System.Text" #> 
<#@ import namespace="System.Text.RegularExpressions" #> 
<#+
void GenerateBnfExpressionClassAndOperators(string bnfExpressionTypeName, string inheritFromBase, IEnumerable<string> implementInterfaces = null, IEnumerable<string> constraints = null,
	IEnumerable<string> bnfTermCoreTypeNames = null, IEnumerable<string> bnfTermCoreExternTypeNames = null, IEnumerable<string> bnfTermSideTypeNames = null, bool allowCorePlusCore = true,
	Func<string, string, bool> filterOutCorePairs = null)
{
	implementInterfaces = implementInterfaces ?? new string[0];
	constraints = constraints ?? new string[0];
	bnfTermCoreTypeNames = bnfTermCoreTypeNames ?? new string[0];
	bnfTermCoreExternTypeNames = bnfTermCoreExternTypeNames ?? new string[0];
	bnfTermSideTypeNames = bnfTermSideTypeNames ?? new string[0];
	filterOutCorePairs = filterOutCorePairs ?? ((bnfTermCoreTypeNames1, bnfTermCoreTypeNames2) => false);

	BeginRegion(string.Format("{0} definition and operators", bnfExpressionTypeName), "\t");

	GenerateBnfExpressionClass(bnfExpressionTypeName, inheritFromBase, implementInterfaces, constraints);
	GenerateBnfExpressionConversionsThere(bnfExpressionTypeName, bnfTermCoreTypeNames);
	GenerateBnfExpressionConversionsHere(bnfExpressionTypeName, bnfTermCoreExternTypeNames);

	if (allowCorePlusCore)
		bnfTermSideTypeNames = bnfTermSideTypeNames.Concat(bnfTermCoreTypeNames).Concat(bnfTermCoreExternTypeNames);

	GenerateBnfExpressionOperators(bnfExpressionTypeName, BnfExprOp.Plus, bnfTermCoreTypeNames, bnfTermSideTypeNames, filterOutCorePairs);
	GenerateBnfExpressionOperators(bnfExpressionTypeName, BnfExprOp.Pipe, bnfTermCoreTypeNames, bnfTermCoreTypeNames.Concat(new[]{bnfExpressionTypeName}), filterOutCorePairs);
	GenerateBnfExpressionOperators(bnfExpressionTypeName, BnfExprOp.Pipe, bnfTermCoreTypeNames, bnfTermCoreExternTypeNames, filterOutCorePairs);

	if (allowCorePlusCore)
		bnfTermSideTypeNames = bnfTermSideTypeNames.Concat(new[]{bnfExpressionTypeName});

	GenerateBnfExpressionOperators(bnfExpressionTypeName, BnfExprOp.Plus, bnfExpressionTypeName, bnfTermSideTypeNames, filterOutCorePairs);
	GenerateBnfExpressionOperators(bnfExpressionTypeName, BnfExprOp.Pipe, bnfExpressionTypeName, bnfTermCoreExternTypeNames.Concat(new[]{bnfExpressionTypeName}), filterOutCorePairs);

	EndRegion("\t");

	PopIndent();
}

void GenerateBnfExpressionClass(string bnfExpressionTypeName, string inheritFromBase, IEnumerable<string> implementInterfaces = null, IEnumerable<string> constraints = null)
{
	implementInterfaces = implementInterfaces ?? new string[0];
	constraints = constraints ?? new string[0];

	string typeParameterName = ExtractFirstTypeParameterName(bnfExpressionTypeName);
	string orTypeParameterString = typeParameterName != null ? "<" + typeParameterName + ">" : string.Empty;

	string bnfExpressionInterfaceName = "I" + bnfExpressionTypeName;

	string bnfExpressionInterfaceDefinitionName = bnfExpressionInterfaceName;
	if (typeParameterName != null)
		bnfExpressionInterfaceDefinitionName = GetTypeNameWithReplacedTypeParameterName(bnfExpressionInterfaceDefinitionName, "out " + typeParameterName);

	string bnfExpressionConstructorName = TypeNameToConstructorName(bnfExpressionTypeName);
#>
	public interface <#= bnfExpressionInterfaceDefinitionName #> <#= implementInterfaces.Any() ? string.Format(": {0}", string.Join(", ", implementInterfaces)) : string.Empty #> { }

	#region <#= bnfExpressionTypeName #> definition

	public partial class <#= bnfExpressionTypeName #> : <#= inheritFromBase #>, <#= bnfExpressionInterfaceName #>
<#+
	WriteConstraints(constraints, "\t\t");
#>
	{
		#region Construction

		public <#= bnfExpressionConstructorName #>()
		{
		}

		public <#= bnfExpressionConstructorName #>(BnfExpression bnfExpression)
			: base(bnfExpression)
		{
		}

        public <#= bnfExpressionConstructorName #>(BnfTerm bnfTerm)
			: base(bnfTerm)
        {
        }

		#endregion

		#region Cast operators

		public static explicit operator <#= bnfExpressionTypeName #>(BnfExpression bnfExpression)
		{
			return new <#= bnfExpressionTypeName #>(bnfExpression);
		}

		#endregion
	}

	#endregion

<#+
}

void WriteConstraints(IEnumerable<string> constraints, string indent)
{
    foreach (string constraint in constraints)
		 WriteLine(indent + "where {0}", constraint);
}

void GenerateBnfExpressionConversionsHere(string bnfExpressionTypeName, IEnumerable<string> bnfTermTypeNamesForConversion)
{
	if (!bnfTermTypeNamesForConversion.Any())
		return;
#>
	#region <#= bnfExpressionTypeName #>: implicit conversions from [<#= string.Join(", ", bnfTermTypeNamesForConversion) #>]

	public partial class <#= bnfExpressionTypeName #>
	{
<#+
	string typeParameterName = ExtractFirstTypeParameterName(bnfExpressionTypeName);

    foreach (string bnfTermTypeNameForConversion in bnfTermTypeNamesForConversion)
    {
#>
		public static implicit operator <#= bnfExpressionTypeName #>(<#= GetTypeNameWithReplacedTypeParameterName(bnfTermTypeNameForConversion, typeParameterName) #> term)
		{
			return new <#= bnfExpressionTypeName #>((BnfTerm)term);
		}
<#+
    }
#>
	}

	#endregion

<#+
}

void GenerateBnfExpressionConversionsThere(string bnfExpressionTypeName, IEnumerable<string> bnfTermTypeNamesForConversion)
{
	if (!bnfTermTypeNamesForConversion.Any())
		return;
#>
	#region [<#= string.Join(", ", bnfTermTypeNamesForConversion) #>]: implicit conversions from <#= bnfExpressionTypeName #>

<#+
    foreach (string bnfTermTypeNameForConversion in bnfTermTypeNamesForConversion)
    {
		string typeParameterName = ExtractFirstTypeParameterName(bnfTermTypeNameForConversion);
		string bnfExpressionTypeNameReplaced = GetTypeNameWithReplacedTypeParameterName(bnfExpressionTypeName, typeParameterName);
#>
	public partial class <#= bnfTermTypeNameForConversion #>
	{
		public static implicit operator <#= bnfExpressionTypeNameReplaced #>(<#= bnfTermTypeNameForConversion #> term)
		{
			return new <#= bnfExpressionTypeNameReplaced #>((BnfTerm)term);
		}
	}

<#+
    }
#>
	#endregion

<#+
}

void GenerateBnfExpressionOperators(string returnTypeName, BnfExprOp op, IEnumerable<string> typeNames, IEnumerable<string> otherTypeNames, Func<string, string, bool> filterOutCorePairs = null)
{
	if (!typeNames.Any() || !otherTypeNames.Any())
		return;

	filterOutCorePairs = filterOutCorePairs ?? ((bnfTermCoreTypeNames1, bnfTermCoreTypeNames2) => false);
	var processedTypeNamePairs = new HashSet<Tuple<string, string>>();

    foreach (string typeName in typeNames)
	{
		var filteredOtherTypeNames = otherTypeNames.Where(otherTypeName => !filterOutCorePairs(typeName, otherTypeName));

		if (!filteredOtherTypeNames.Any())
			continue;

#>
	#region <#= typeName #> '<#= BnfExprOpToSign(op) #>' operators for BnfExpression

	public partial class <#= typeName #>
	{
<#+
		string typeParameterName = ExtractFirstTypeParameterName(typeName);
	    foreach (string otherTypeName in filteredOtherTypeNames)
		{
			if (processedTypeNamePairs.Contains(Tuple.Create(typeName, otherTypeName)) ||
				processedTypeNamePairs.Contains(Tuple.Create(otherTypeName, typeName)))
			{
				continue;
            }

			GenerateBnfExpressionOperatorMethod(
				GetTypeNameWithReplacedTypeParameterName(returnTypeName, typeParameterName),
				op,
				GetTypeNameWithReplacedTypeParameterName(typeName, typeParameterName),
				GetTypeNameWithReplacedTypeParameterName(otherTypeName, typeParameterName)
			);

			WriteLine();

			processedTypeNamePairs.Add(Tuple.Create(typeName, otherTypeName));
        }
#>
	}

	#endregion

<#+
    }
}

void GenerateBnfExpressionOperators(string returnTypeName, BnfExprOp op, string typeName, IEnumerable<string> otherTypeNames, Func<string, string, bool> filterOutCorePairs = null)
{
	if (!otherTypeNames.Any())
		return;

	filterOutCorePairs = filterOutCorePairs ?? ((bnfTermCoreTypeNames1, bnfTermCoreTypeNames2) => false);
#>
	#region <#= typeName #> '<#= BnfExprOpToSign(op) #>' operators for BnfExpression

	public partial class <#= typeName #>
	{
<#+
		string typeParameterName = ExtractFirstTypeParameterName(typeName);
		GenerateBnfExpressionOperatorMethods(
			GetTypeNameWithReplacedTypeParameterName(returnTypeName, typeParameterName),
			op,
			typeName,
			otherTypeNames
				.Where(otherTypeName => !filterOutCorePairs(typeName, otherTypeName))
				.Select(otherTypeName => GetTypeNameWithReplacedTypeParameterName(otherTypeName, typeParameterName))
		);
#>
	}

	#endregion

<#+
}

void GenerateBnfExpressionOperatorMethods(string returnTypeName, BnfExprOp op, string paramTypeName1, IEnumerable<string> paramTypeNames2)
{
    foreach (string paramTypeName2 in paramTypeNames2)
	{
		GenerateBnfExpressionOperatorMethod(returnTypeName, op, paramTypeName1, paramTypeName2);
		WriteLine();
    }
}

void GenerateBnfExpressionOperatorMethod(string returnTypeName, BnfExprOp op, string paramTypeName1, string paramTypeName2)
{
	GenerateOneWayExpressionOperatorMethod(returnTypeName, op, paramTypeName1, paramTypeName2);
	if (paramTypeName1 != paramTypeName2)
    {
		WriteLine();
		GenerateOneWayExpressionOperatorMethod(returnTypeName, op, paramTypeName2, paramTypeName1);
    }
}

void GenerateOneWayExpressionOperatorMethod(string returnTypeName, BnfExprOp op, string paramTypeName1, string paramTypeName2)
{
	if (op == BnfExprOp.Both)
	{
		GenerateOneWayExpressionOperatorMethod(returnTypeName, BnfExprOp.Plus, paramTypeName1, paramTypeName2);
		GenerateOneWayExpressionOperatorMethod(returnTypeName, BnfExprOp.Pipe, paramTypeName1, paramTypeName2);
    }
	else
    {
#>
        public static <#= returnTypeName #> operator <#= BnfExprOpToSign(op) #>(<#= paramTypeName1 #> term1, <#= paramTypeName2 #> term2)
        {
            return (<#= returnTypeName #>)BnfTerm.<#= BnfExprOpToMethodName(op) #>((BnfTerm)term1, (BnfTerm)term2);
        }
<#+
    }
}

string BnfExprOpToSign(BnfExprOp op)
{
	switch (op)
    {
		case BnfExprOp.Pipe:	return "|";
		case BnfExprOp.Plus:	return "+";
		case BnfExprOp.Both:	return "+|";
		default:				throw new ArgumentException("Unknown bnfExpression operator", "op");
    }
}

string BnfExprOpToMethodName(BnfExprOp op)
{
	switch (op)
    {
		case BnfExprOp.Pipe:	return "Op_Pipe";
		case BnfExprOp.Plus:	return "Op_Plus";
		default:				throw new ArgumentException("Unknown bnfExpression operator", "op");
    }
}

void WriteLine()
{
	WriteLine(string.Empty);
}

void BeginRegion(string regionName, string indent = "")
{
	WriteLine(indent + "#region {0}", regionName);
	WriteLine();
}

void EndRegion(string indent = "")
{
	WriteLine(indent + "#endregion");
	WriteLine();
}

[Flags] enum BnfExprOp { Plus = 1, Pipe = 2, Both = Plus | Pipe }

string TypeNameToConstructorName(string typeName)
{
	var match = Regex.Match(typeName, @"(\w+)<");
	return match.Success ? match.Groups[1].Value : typeName;
}

string ExtractFirstTypeParameterName(string typeName)
{
	var match = Regex.Match(typeName, @"<(\w+)[>,]");
	return match.Success ? match.Groups[1].Value : null;
}

string GetTypeNameWithReplacedTypeParameterName(string typeName, string newTypeParameterName)
{
	return newTypeParameterName != null
		? Regex.Replace(typeName, @"<(\w+)>", string.Format("<{0}>", newTypeParameterName))
		: typeName;
}
#>
